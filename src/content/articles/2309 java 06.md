---
title: "Java Learning Notes 06: Exceptions"
description: "A practical overview of Java's exception system: Error vs Exception, checked vs runtime exceptions, handling patterns, and custom exceptions."
pubDate: "Jun 20 2023"
tags: ["java", "programming", "beginner", "exceptions", "error-handling"]
---

# Java Study Notes 06: Exceptions

# 1 Overview

**An exception is an unexpected condition that occurs while a program is running, such as a missing file, a failed network connection, or an illegal argument.**

Exceptions occur at runtime and disrupt the normal flow of program execution.

## 1.1 Types of Exceptions

- Checked exceptions: Typically caused by external factors or user errors that the programmer cannot fully predict. For example, trying to open a file that does not exist will cause an exception. These exceptions cannot simply be ignored at compile time; the compiler requires you to either handle or declare them.
- Runtime exceptions: These are exceptions that could, in principle, be avoided by writing better code. Unlike checked exceptions, runtime exceptions are unchecked and may be ignored by the compiler.
- Errors: Errors are not the same as exceptions; they represent conditions that are generally outside a programmer’s control. Errors are usually ignored in code. For example, a stack overflow triggers an error. Errors cannot be detected or recovered from safely at compile time.

Java treats exceptions as objects and defines the base class `java.lang.Throwable` as the root of all error and exception types.

The Java API defines many exception classes, which fall into two broad categories: `Error` and `Exception`.

## 1.2 `Error`

`Error` instances are created and thrown by the Java Virtual Machine (JVM). Most errors are unrelated to the specific application logic written by the developer.

Examples include virtual machine errors such as `OutOfMemoryError` when the JVM runs out of memory. When such errors occur, the JVM usually terminates the current thread, and often the application cannot recover cleanly.

Other examples occur when the JVM attempts to run an application but encounters basic problems such as `NoClassDefFoundError` or `LinkageError`. These are generally not meant to be caught or handled in application code, because they fall outside normal program control and represent states where the program is not expected to continue.

## 1.3 `Exception`

Within `Exception` there is an important subclass: `RuntimeException`.

Common runtime exceptions include:

- `ArrayIndexOutOfBoundsException`
- `NullPointerException`
- `ArithmeticException`
- `MissingResourceException`
- `ClassNotFoundException`

These are unchecked exceptions; your code may choose to catch them or not.

Most runtime exceptions are caused by programming logic errors. Ideally, you should design your code to avoid them as much as possible.

Difference between `Error` and `Exception`:

- `Error` usually represents catastrophic, unrecoverable conditions that your program cannot reasonably control or handle. When such errors occur, the JVM typically terminates the thread (or the whole application).
- `Exception` represents conditions that your program can usually anticipate and handle. Your code should handle exceptions as appropriately as possible rather than letting them crash the application.

------

# 2 Exception Handling Mechanism

- Throwing exceptions
- Catching exceptions
- The five core keywords for exception handling

`try`, `catch`, `finally`, `throw`, `throws`

Example:

```java
try {
    System.out.println(1 / 0);
} catch (ArithmeticException e) {
    System.out.println("An exception occurred in the program");
} finally {
    System.out.println("finally");
}
```

# 3 Custom Exceptions

Java’s built-in exception classes cover most cases you encounter in everyday programming. In addition, you can define your own exception types. To create a custom exception, simply extend the `Exception` class (or another appropriate exception base class).

Example:

```java
public class MyException extends Exception {

    private int detail;

    public MyException(int a) {
        this.detail = a;
    }

    @Override
    public String toString() {
        return "MyException(" + detail + ')';
    }
}
```

Guidelines:

- When dealing with runtime exceptions, first try to prevent them through sound program logic, and then supplement with `try-catch` where appropriate.
- After multiple specific `catch` blocks, you can add a `catch (Exception e)` block to handle any exceptions that might have slipped through.
- For code whose behavior is uncertain or involves external resources, you can wrap it in `try-catch` to handle potential exceptions.
- Aim to handle exceptions thoughtfully, based on both the business requirements and the specific exception types.
- The exact handling strategy should always be guided by your business logic and failure modes.
- Use `finally` blocks wherever appropriate to release resources such as files, database connections, and network sockets.
