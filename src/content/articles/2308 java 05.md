---
title: "Java Learning Notes 05: Object-Oriented Programming"
description: "An overview of Java's object-oriented concepts: classes, objects, encapsulation, inheritance, polymorphism, interfaces, and more."
pubDate: "Jun 15 2023"
tags: ["java", "programming", "beginner", "jdk", "syntax"]
---

# Java Study Notes 05: Object-Oriented Programming

# 1 Overview

## 1.1 Procedural vs Object-Oriented

**Procedural programming:**

The steps are clear and linear: first do step one, then step two, and so on.

Procedural thinking works well for relatively simple, well-defined tasks.

**Object-oriented programming:**

Think in terms of “grouping by type”. First figure out which kinds of things (categories) are involved in the problem, then think about each category separately. Only after that do you think about the detailed, step-by-step logic inside each category.

Object-oriented thinking is better for complex problems and for problems that require collaboration among multiple people.

**When describing complex systems, we use object-oriented thinking to understand and analyze the system from a high level. But when we get down to low-level operations, we still implement the details procedurally.**

## 1.2 What is Object-Oriented Programming?

- Object-Oriented Programming (OOP)
- The essence of OOP is: **use classes to organize code, and use objects to encapsulate data.**
- Abstraction
- The three core features:
- Encapsulation
- Inheritance
- Polymorphism
- From an epistemological point of view, objects come first and classes come later. An object is a concrete thing; a class is an abstraction of a set of similar objects.
- From a code execution point of view, classes come first and objects come later. A class is the template for its objects.

------

# 2 Quick Review of Methods

- Method definition
- Modifiers
- Return types
- The difference between `break` and `return`
- Method names
- Parameter lists
- Declaring thrown exceptions
- Calling methods
- Static methods
- Instance (non-static) methods
- Parameters vs arguments
- Pass-by-value vs reference semantics
- The `this` keyword

------

# 3 Relationship Between Classes and Objects

**A class is an abstract data type: it describes a whole category of things, but it does not represent any one concrete instance.**

**An object is a concrete instance of that abstract concept.**

```java
package com.oop.demo02;

// Student class
public class Student {

    // Fields / properties
    String name;
    int age;

    // Methods
    public void study() {
        System.out.println(this.name + " is studying");
    }
}

package com.oop.demo02;

// A project should ideally have only one main entry point
public class Application {
    public static void main(String[] args) {

        // A class is abstract; you create objects by instantiating it.
        // Instantiating a class returns an object of that class.
        // The variable xiaoming is a concrete instance of Student.

        Student xiaoming = new Student();

        xiaoming.name = "Xiao Ming";
        xiaoming.age = 3;

        System.out.println(xiaoming.name);
        System.out.println(xiaoming.age);
    }
}
```

------

# 4 Constructors in Detail

*When you create an object with the `new` keyword, the JVM not only allocates memory but also performs default initialization and calls the class’s constructor.*

The constructor in a class (also called a constructor method) is what must be called when creating an object. Constructors have two key characteristics:

- The constructor name must be the same as the class name.
- A constructor has no return type, and you do not even write `void`.

Example:

```java
package com.oop.demo02;

public class Application {
    public static void main(String[] args) {
        Person person = new Person();
        // Using the new keyword essentially means “call a constructor”.
        // The compiler selects the appropriate constructor based on the arguments.
    }
}

package com.oop.demo02;

public class Person {
    // Even if you do not explicitly declare a constructor,
    // the compiler will provide a default no-argument constructor.
    String name;

    public Person(String name) {
        this.name = name;
    }
}
```

# 5 Encapsulation

- Expose what should be exposed; hide what should be hidden.

In program design we aim for **high cohesion and low coupling**. High cohesion means the internal data and operations of a class are handled inside the class without unnecessary external interference. Low coupling means exposing only a small, well-defined set of methods for external use.

- Encapsulation (data hiding)

Typically, direct access to an object’s internal data representation is forbidden. Instead, we expose methods as an operation interface. This is known as information hiding.

- Remember: make fields private, and provide getters and setters.

Example:

```java
public class Student {
    // Name
    private String name;
    // Student ID
    private int id;
    // Gender
    private char gender;

    // Provide methods to access and modify the fields
    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

------

# 6 Inheritance

The essence of inheritance is to abstract common features from a group of classes so that we can model the real world more effectively.

`extends` literally means “extends”. A subclass is an extension of its superclass.

In Java, a class can have only one direct superclass (single inheritance). There is no multiple inheritance for classes.

Inheritance is one kind of relationship between classes. Other relationships include dependency, composition, and aggregation.

In an inheritance relationship, one class is the subclass (derived class), and the other is the superclass (base class). The subclass uses the `extends` keyword to inherit from the superclass.

From a semantic point of view, the subclass and superclass should have an **“is-a”** relationship.

- `Object` class
- `super`
- Method overriding

Example:

```java
public class Person {
}

public class Student extends Person {
}
```

- A subclass inherits all `public` methods of its superclass.
- In Java, all classes implicitly extend `Object` if no other superclass is specified.
- `super` refers to the superclass context. Subclasses can use `super` to access superclass fields and methods, but not `private` ones.
- When creating an object, the superclass constructor runs first, then the subclass constructor. An explicit call to a superclass constructor must be the first statement in the subclass constructor.

**Method overriding**

- Overriding always applies to methods: a subclass provides its own implementation of a superclass method.
- The method name must be the same, and the parameter list must be the same; only the method body changes.
- Static methods and instance methods behave differently; overriding only applies to instance (non-static) methods. Static methods are resolved based on the reference type.
- Access modifiers can be relaxed (widened) in the overriding method (`public > protected > default > private`).
- The set of checked exceptions declared by the overriding method can be the same or more specific (narrower), but not broader.

Why override?

Because the superclass implementation may not fully satisfy the requirements of the subclass, or the subclass may need more specific behavior.

------

# 7 Polymorphism

## 7.1 What is Polymorphism?

Polymorphism means that the same method call can exhibit different behaviors depending on the actual object that receives the call.

The actual type of an object is fixed once it is created, but the type of the reference pointing to it can vary.

Conditions for polymorphism:

- There is an inheritance relationship.
- The subclass overrides a superclass method.
- A superclass reference refers to a subclass object.

**Note: polymorphism applies to methods, not to fields. Fields do not have polymorphic behavior.**

The actual type of an object is fixed:

```java
new Person();
```

But the reference type that can point to an object is flexible:

```java
Student s1 = new Student();
Person s2 = new Student();
Object s3 = new Student();
// A superclass reference pointing to a subclass object
```

**Which methods an object can call is determined primarily by the reference type, not by the constructor used to create the object.**

For example, `s1` can call its own methods and those it inherits from `Person`. `s2` cannot directly call methods that exist only in `Student`, but if `Student` overrides a method from `Person`, calling that method on `s2` will execute the subclass implementation.

To call subclass-specific methods through a superclass reference:

```java
((Student) s2).eat();
// The superclass and subclass must have a valid relationship,
// otherwise a ClassCastException will be thrown.
```

Notes:

- `static` members belong to the class, not to instances.
- `final` represents constants or methods that cannot be overridden.
- `private` methods cannot be overridden.

## 7.2 The `instanceof` Keyword

**`instanceof` is used to test whether two types have an inheritance (parent–child) relationship.**

```java
Object object = new Student();

System.out.println(object instanceof Student);
System.out.println(object instanceof Person);
System.out.println(object instanceof Object);
System.out.println(object instanceof Teacher);
System.out.println(object instanceof String);

/*
true
true
true
false
false
*/
```

## 7.3 Type Casting

1. Use a superclass reference to point to a subclass object.
2. Casting a subclass reference to a superclass type is called upcasting.
3. Casting a superclass reference back to a subclass type is called downcasting; this requires an explicit cast.
4. Proper casting makes it easier to work with APIs and reduces duplicate code.

------

# 8 The `static` Keyword

```java
// Static import
import static java.lang.Math.random;

public class Student {
    private static int age;   // Static field
    private double score;     // Instance field

    public static void main(String[] args) { // Static methods load with the class
        Student s1 = new Student();

        System.out.println(Student.age);
        System.out.println(s1.age);
        System.out.println(s1.score);

        System.out.println(random());
    }

    {
        // Instance initializer block, runs before the constructor
    }

    static {
        // Static initializer block, runs once when the class is loaded
    }
    // Execution order: static block -> instance initializer -> constructor
}
```

# 9 Abstract Classes

- The `abstract` modifier can be applied to methods and classes. An `abstract` method has no body. A class containing abstract methods must be declared abstract.
- An abstract class may contain no abstract methods, but any class with abstract methods must be abstract. An abstract class can also contain regular (concrete) methods.
- You cannot create instances of an abstract class with `new`. Abstract classes are meant to be extended.
- Abstract methods provide only a declaration, no implementation; subclasses must implement them.
- A subclass that extends an abstract class must implement all inherited abstract methods; otherwise, the subclass itself must be declared abstract.
- Abstract classes can define constructors, which are called by subclass constructors.

Example:

```java
// Abstract class
public abstract class Action {

    // Abstract method
    public abstract void doSomething();
}
```

------

# 10 Interfaces

**An interface defines a contract; it only specifies behavior, it does not provide implementation.**

- An interface is a set of rules that a class agrees to follow. It models ideas like “if you are a X, you must be able to do Y”.
- The essence of an interface is a contract.
- The core of OOP is abstraction, and interfaces are one of the best tools to express it.

**Interfaces are declared with the `interface` keyword.**

```java
public interface UserService {
    // All members are implicitly public and abstract
    void add(String name);
    void delete(String name);
    void update(String name);
    void query(String name);
}

public interface Time {
    // Fields in interfaces are implicitly public static final
    int AGE = 99;
    void count(int time);
}

// Interfaces must have implementation classes
public class UserServiceImpl implements UserService, Time {
    @Override
    public void add(String name) {

    }

    @Override
    public void delete(String name) {

    }

    @Override
    public void update(String name) {

    }

    @Override
    public void query(String name) {

    }

    @Override
    public void count(int time) {

    }
}
```

Roles of interfaces:

1. Provide constraints.
2. Define methods that different classes can implement in their own way.
3. Members are `public abstract` by default.
4. Fields are `public static final` by default.
5. 接口不能被实例化。
6. implements可以实现多个接口。
7. 必须要重写接口中的方法。

------

# 11 内部类

- 成员内部类
- 静态内部类
- 局部内部类
- 匿名内部类

**示例代码**

```java
public class Outer {

    //成员内部类
    public class Inner {
        //TODO
    }

    //静态内部类
    public static class Inner1{
        //TODO
    }

    public void method(){
        //局部内部类
        class Inner2{
            //TODO
        }
    }

    //匿名内部类不用将实例保存到变量中
}
Outer outer = new Outer();
Outer.Inner inner = outer.new Inner();
```

内部类可以访问外部类的一些私有属性。
